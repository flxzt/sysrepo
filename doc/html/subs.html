<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" lang="en-US">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=11"/>
<meta name="generator" content="Doxygen 1.12.0"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>sysrepo: Subscriptions</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<script type="text/javascript" src="clipboard.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="cookie.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<link href="cesnet-style.css" rel="stylesheet" type="text/css"/>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr id="projectrow">
  <td id="projectlogo"><img alt="Logo" src="logo.png"/></td>
  <td id="projectalign">
   <div id="projectname">sysrepo<span id="projectnumber">&#160;2.2.117</span>
   </div>
   <div id="projectbrief">YANG-based system repository for all-around configuration management.</div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.12.0 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
var searchBox = new SearchBox("searchBox", "search/",'.html');
/* @license-end */
</script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() { codefold.init(0); });
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function() {
  initMenu('',true,false,'search.php','Search',true);
  $(function() { init_search(); });
});
/* @license-end */
</script>
<div id="main-nav"></div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:d3d9a9a6595521f9666a5e94cc830dab83b65699&amp;dn=expat.txt MIT */
$(function(){initNavTree('subs.html',''); initResizable(true); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<div id="MSearchResults">
<div class="SRPage">
<div id="SRIndex">
<div id="SRResults"></div>
<div class="SRStatus" id="Loading">Loading...</div>
<div class="SRStatus" id="Searching">Searching...</div>
<div class="SRStatus" id="NoMatches">No Matches</div>
</div>
</div>
</div>
</div>

<div><div class="header">
  <div class="headertitle"><div class="title">Subscriptions</div></div>
</div><!--header-->
<div class="contents">
<div class="textblock"><p>Every <code>*_subscribe()</code> call will return a subscription structure. It is possible to subscribe using an existing subscription and then multiple events will be handled by a single subscription. By default, there is a dedicated thread for handling all the events in a subscription structure so no further action is required.</p>
<p>If this is not desired, it is possible to handle events on a subscription without a separate thread. When subscribing, the flag <a class="el" href="group__subs__api.html#ggaa629478596b1e246553eac91a74b2b5ba950de919456aa8d277b9dd6d465ad2e0" title="There will be no thread created for handling this subscription meaning no event will be processed!...">SR_SUBSCR_NO_THREAD</a> needs to be used so that the thread is not created. Be careful, if you use it, the subscription exists and events can occur but they are not being handled so they can time out, for example, unless processed manually. That can be achieved by a function that processes all pending events on a subscription. <a class="el" href="group__subs__api.html#ga2345e433621ad3b9a8212fbbfc86dbc5" title="Process any pending new events on a subscription. Should not be called unless SR_SUBSCR_NO_THREAD fla...">sr_subscription_process_events()</a> can either be called periodically or only when there are actual events. This can be learnt by the <a class="el" href="group__subs__api.html#gae87f7a55b60c13c69d813121778fd1a1">subscription event pipe</a> being ready for reading.</p>
<p>To safely destroy a subscription managed by a custom loop, there are specific steps needed. First, <a class="el" href="group__subs__api.html#ga369f62715baed57ad5aabbd92e315347" title="Unsubscribe a specific or all the subscriptions in a subscription structure.">sr_unsubscribe_sub()</a> with <code>sub_id</code> <code>0</code> should be called, then the event loop should stop handling events on the subscription, and finally <a class="el" href="group__subs__api.html#ga8fe49b0cf74d5744cae2aa47d13d480b" title="Unsubscribe all the subscriptions in a subscription structure and free it.">sr_unsubscribe()</a> can be called. This prevents the data race when there is a pending event but it is not processed because the subscription is being freed.</p>
<p><a class="el" href="group__subs__api.html">Subscription API</a></p>
<h2><a class="anchor" id="autotoc_md24"></a>
Change Subscriptions</h2>
<p><a class="anchor" id="change_subs"></a> These are the most common kinds of subscriptions. A callback can be set to be called when specific data changes occur so that it can appropriately react and adjust the system or whatever it manages accordingly. There can be many subscribers for the same data and arbitrary XPath filters can be applied.</p>
<p>Any datastore can be subscribed to (startup, running, and operational). The datastore is determined by the current datastore at the time of subscription (that is, the call to <a class="el" href="group__change__subs__api.html#ga9fc19731882299fe1864ccc20b9bd842" title="Subscribe for changes made in the specified module.">sr_module_change_subscribe()</a>). Changing the active datastore after that does not have an effect on subscriptions that have already been made. For example, it is possible to subscribe to running datastore, switch to the startup datastore, subscribe to it, and then switch back to edit the running datastore all with one session and one subscription context.</p>
<p>On changes, the callback is called with an event. By default, there are always 2 events following one after the other. On <em>change</em>, the new datastore content is prepared but not written yet and so the changes can be refused for any reason. If they are not, the changes are committed and hence visible for any subsequent operations. Right after that <em>done</em> event is generated and callbacks called. It is no longer possible to revert the changes. In case at least one of the callbacks has failed during <em>change</em> event, the whole commit is aborted. Callbacks that already processed the <em>change</em> event successfully will be called with <em>abort</em> event so they can revert them and keep Sysrepo and the system consistent.</p>
<p>There is one special event <em>update</em> that is generated only for subscriptions that request it. This event occurs before any of the other ones mentioned before because it allows to further modify the data changes that are being handled. Callback with this event can fail and cause the changes to be immediately refused.</p>
<p>Also, a subscription can request the <em>enabled</em> event and get the current datastore configuration at the time of subscribing. This event is normally followed by <em>done</em> event, just like the <em>change</em> event. However, the <em>enabled</em> event is generated even if the current configuration is empty (so there will be no changes available in the callback)!</p>
<p>When subscribing to <em>operational</em> datastore changes, be aware of some specific conditions. Normally, only <a class="el" href="index.html#oper_data">push</a> changes are acknowledged and callbacks called. Changes in pull subscriptions are reported only if a corresponding <a class="el" href="#oper_subs">operational poll subscription</a> is created.</p>
<p>On the events <em>update</em> and <em>change</em>, the callback can return a special <a class="el" href="group__log__api.html#gga3541b16be4e12bd061b7e24d4be29c30aa297b02a06472aa8df2e971b9b1c77fe">SR_ERR_CALLBACK_SHELVE</a> value. This causes the event not to be processed and simply skipped (shelved). When all the events on the subscription are processed next time, this subscription callback with the same event is called again. This special return value can be returned several times but be careful for the timeout not to elapse! Typically, this whole mechanism is used only when the events are handled by the application, not by a Sysrepo thread (<a class="el" href="group__subs__api.html#ggaa629478596b1e246553eac91a74b2b5ba950de919456aa8d277b9dd6d465ad2e0" title="There will be no thread created for handling this subscription meaning no event will be processed!...">SR_SUBSCR_NO_THREAD</a>). Otherwise the application does not have full control over calling the event processing function <a class="el" href="group__subs__api.html#ga2345e433621ad3b9a8212fbbfc86dbc5" title="Process any pending new events on a subscription. Should not be called unless SR_SUBSCR_NO_THREAD fla...">sr_subscription_process_events()</a> (strictly speaking, it can be called directly even if Sysrepo thread is handling this subscription, but there is likely no use-case).</p>
<p>For each of these events, the changes are retrieved using an iterator, which can be created several times and optionally with only selected changes.</p>
<p>It is important to be aware of the effect of subscribing to <em>running</em> data on <a class="el" href="index.html#oper_ds">operational datastore</a>.</p>
<p><a class="el" href="group__change__subs__api.html">Change Data Subscription API</a></p>
<h2><a class="anchor" id="autotoc_md25"></a>
RPC/Action Subscriptions</h2>
<p><a class="anchor" id="rpc_subs"></a> All the functions can be used for both RPCs and actions. If there are no matching subscriptions, the RPC/action cannot even be sent. Callbacks work as one would expect, on <em>rpc</em> event they are provided each with the input and can fail or succeed with optionally generating some output that is sent back to the original sender. There can be predicates on the subscription XPath filtering only specific RPC/action instances.</p>
<p>In case there are several subscriptions matching a single RPC/action, there can only be <b>one</b> subscription with a specific priority. This lowest priority (main) subscription will be the one generating output for the sender (previous outputs will be overwritten) and, additionally, will never receive the <em>abort</em> event (in case it fails, only all the other higher priority callbacks will be aborted).</p>
<p>RPC subscriptions can also return <a class="el" href="group__log__api.html#gga3541b16be4e12bd061b7e24d4be29c30aa297b02a06472aa8df2e971b9b1c77fe">SR_ERR_CALLBACK_SHELVE</a> on <em>rpc</em> event.</p>
<p><a class="el" href="group__rpc__subs__api.html">RPC/Action Subscription API</a></p>
<h2><a class="anchor" id="autotoc_md26"></a>
Notification Subscriptions</h2>
<p><a class="anchor" id="notif_subs"></a> Notifications are supported by specific subscriptions that allow them to be sent and received. Sent notification are also stored for possible future replay if the particular module was configued that way (mentioned in <a class="el" href="schema.html">schemas</a>).</p>
<p>When subscribing to notifications, there are several options that can be specified and which follow the definitions from <a class="el" href="index.html#rfcs">NETCONF Notifications RFC</a>. Normally, all notifications are <em>real-time</em>. If replay is requested, these are <em>replay</em> notifications. If a replay finished and the subscription changes into a standard one, <em>replay complete</em> notification is delivered. Lastly, once the subscription should be terminated because its stop time was reached, <em>stop</em> is received before removing the subscription.</p>
<p><a class="el" href="group__notif__subs__api.html">Notification Subscription API</a></p>
<h2><a class="anchor" id="autotoc_md27"></a>
Operational Subscriptions</h2>
<p><a class="anchor" id="oper_subs"></a> There are 2 types of operational subscriptions that are completely different. Operational <b>get</b> subscriptions allow providing data that are requested by clients. Commonly, these can be used to read the current state of a device, for example, and then return them as <em>state</em> data nodes. However, they can also be used to provide <em>configuration</em> data nodes. In that case they should return only the configuration that is actually in-use by the managed device. Much more details and explanations can be found in the <a class="el" href="index.html#rfcs">NMDA RFC</a>.</p>
<p>Any operational get subscription is meant to provide all nodes in the subtree it is subscribed for. All the previous nodes (copied from <em>running</em> datastore, provided by <a class="el" href="index.html#oper_data">push operational data</a>, or even by previous operational get subscription) are replaced by the new ones provided. This behavior can be changed and the previous nodes merged if <a class="el" href="group__subs__api.html#ggaa629478596b1e246553eac91a74b2b5bad8c77539582e1de78f57e256299ea138" title="Instead of removing any previous existing matching data before getting them from an operational subsc...">SR_SUBSCR_OPER_MERGE</a> option is used for the subscription. That can be useful, for example, for a scenario such as providing some state data nodes into a subtree with configuration nodes as well, which are desired to be kept.</p>
<p>Operational <b>poll</b> subscriptions are special kind of subscriptions that do not call any callback. Instead, they periodically request data of an operational get subscription and store them in the connection. Then, whenever these data are required by a session on the connection, these cached data are used instead of calling the callback of the operational get subscription. In addition to this caching mechanism, on every cache refresh these subscriptions can optionally generate a list of changes (diff) that is reported to any <a class="el" href="#change_subs">change</a> subscribers on the particular data.</p>
<p>When using <a class="el" href="index.html#oper_data">pull operational get data</a> subscriptions, the subscription must be <b>actively handling events</b> whenever <b>operational datastore data of the module are requested</b> (so these 2 operations cannot occur in a single thread and they must have individual subscription structures) to <b>avoid a time out</b>. Note that operational datastore data are required not only when requested explicitly using a getter but also when validating operational datastore (all modules or the same module), setting push operational data (for the same module), sending an RPC/action or a notification (if the specific module data are required for validation), or an operational poll subscription refreshing the cache.</p>
<p>Operational callback is not called unless its data are required so keep these rules in mind:</p>
<ul>
<li><p class="startli">if the parent of the provided data does not exist in the <b>operational</b> datastore, neither can its descendants, see <a class="el" href="index.html#oper_data">operational data</a> for details about data existence;</p>
<p class="startli"><em>Example</em>: If you subscribed for providing <code>/mod:config-container/config-list/state-leaf</code>, your callback would be called for every existing instance of <code>/mod:config-container/config-list</code>, not at all if there was none.</p>
</li>
<li><p class="startli">in case there are nested subscriptions, the deeper ones are called last so their parents can be created;</p>
<p class="startli"><em>Example</em>: If you subscribed to <code>/mod:config-container/config-list</code> and <code>/mod:config-container/config-list/state-leaf</code>, the former callback would be called before the latter, so whatever <em>list</em> instances were created in that first call, only for those would then the <em>leaf</em> value be retrieved.</p>
</li>
<li><p class="startli">if a filter is used that does not select the data provided by a callback, this callback is <em>usually</em> not called. This redundancy check is performed only textually so it will never cover all the cases.</p>
<p class="startli"><em>Example</em>: If you subscribed to <code>/mod:config-container/config-list[key="val"]</code> and then <code>/mod:config-container/state-list/*</code> was requested, your callback <b>would not</b> be called. <b>Neither would</b> it be called when <code>/mod:config-container/config-list[key="val2"]</code> was requested. However, if <code>/mod:config-container/config-list/key[.="val2"]</code> was used as the filter (even though there is no reason to use such a path), the callback <b>would</b> be called and the returned data filtered out later.</p>
</li>
</ul>
<p>Finally, just like configuration and RPC subscription, operational subscription callback can return <a class="el" href="group__log__api.html#gga3541b16be4e12bd061b7e24d4be29c30aa297b02a06472aa8df2e971b9b1c77fe">SR_ERR_CALLBACK_SHELVE</a>.</p>
<p><a class="el" href="group__oper__subs__api.html">Operational Data Subscription API</a> </p>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dev_guide.html">Developer Guide</a></li>
    <li class="footer">Generated on Tue Jan 28 2025 10:56:44 for sysrepo by <a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.12.0 </li>
  </ul>
</div>
</body>
</html>
